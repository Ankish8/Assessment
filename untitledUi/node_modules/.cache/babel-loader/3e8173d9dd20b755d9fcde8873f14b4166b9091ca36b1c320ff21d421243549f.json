{"ast":null,"code":"\"use client\";\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/index.tsx\nimport React, { cloneElement, isValidElement, useCallback, useEffect as useEffect2, useReducer, useRef as useRef2, useState } from \"react\";\nimport convert2 from \"react-from-dom\";\n\n// src/config.ts\nvar CACHE_NAME = \"react-inlinesvg\";\nvar CACHE_MAX_RETRIES = 10;\nvar STATUS = {\n  IDLE: \"idle\",\n  LOADING: \"loading\",\n  LOADED: \"loaded\",\n  FAILED: \"failed\",\n  READY: \"ready\",\n  UNSUPPORTED: \"unsupported\"\n};\n\n// src/modules/helpers.ts\nfunction randomCharacter(character) {\n  return character[Math.floor(Math.random() * character.length)];\n}\nfunction canUseDOM() {\n  return !!(typeof window !== \"undefined\" && window.document?.createElement);\n}\nfunction isSupportedEnvironment() {\n  return supportsInlineSVG() && typeof window !== \"undefined\" && window !== null;\n}\nfunction omit(input, ...filter) {\n  const output = {};\n  for (const key in input) {\n    if ({}.hasOwnProperty.call(input, key)) {\n      if (!filter.includes(key)) {\n        output[key] = input[key];\n      }\n    }\n  }\n  return output;\n}\nfunction randomString(length) {\n  const letters = \"abcdefghijklmnopqrstuvwxyz\";\n  const numbers = \"1234567890\";\n  const charset = `${letters}${letters.toUpperCase()}${numbers}`;\n  let R = \"\";\n  for (let index = 0; index < length; index++) {\n    R += randomCharacter(charset);\n  }\n  return R;\n}\nasync function request(url, options) {\n  const response = await fetch(url, options);\n  const contentType = response.headers.get(\"content-type\");\n  const [fileType] = (contentType ?? \"\").split(/ ?; ?/);\n  if (response.status > 299) {\n    throw new Error(\"Not found\");\n  }\n  if (![\"image/svg+xml\", \"text/plain\"].some(d => fileType.includes(d))) {\n    throw new Error(`Content type isn't valid: ${fileType}`);\n  }\n  return response.text();\n}\nfunction sleep(seconds = 1) {\n  return new Promise(resolve => {\n    setTimeout(resolve, seconds * 1e3);\n  });\n}\nfunction supportsInlineSVG() {\n  if (!document) {\n    return false;\n  }\n  const div = document.createElement(\"div\");\n  div.innerHTML = \"<svg />\";\n  const svg = div.firstChild;\n  return !!svg && svg.namespaceURI === \"http://www.w3.org/2000/svg\";\n}\n\n// src/modules/cache.ts\nvar CacheStore = class {\n  constructor() {\n    __publicField(this, \"cacheApi\");\n    __publicField(this, \"cacheStore\");\n    __publicField(this, \"subscribers\", []);\n    __publicField(this, \"isReady\", false);\n    this.cacheStore = /* @__PURE__ */new Map();\n    let cacheName = CACHE_NAME;\n    let usePersistentCache = false;\n    if (canUseDOM()) {\n      cacheName = window.REACT_INLINESVG_CACHE_NAME ?? CACHE_NAME;\n      usePersistentCache = !!window.REACT_INLINESVG_PERSISTENT_CACHE && \"caches\" in window;\n    }\n    if (usePersistentCache) {\n      caches.open(cacheName).then(cache => {\n        this.cacheApi = cache;\n      }).catch(error => {\n        console.error(`Failed to open cache: ${error.message}`);\n        this.cacheApi = void 0;\n      }).finally(() => {\n        this.isReady = true;\n        const callbacks = [...this.subscribers];\n        this.subscribers.length = 0;\n        callbacks.forEach(callback => {\n          try {\n            callback();\n          } catch (error) {\n            console.error(`Error in CacheStore subscriber callback: ${error.message}`);\n          }\n        });\n      });\n    } else {\n      this.isReady = true;\n    }\n  }\n  onReady(callback) {\n    if (this.isReady) {\n      callback();\n    } else {\n      this.subscribers.push(callback);\n    }\n  }\n  async get(url, fetchOptions) {\n    await (this.cacheApi ? this.fetchAndAddToPersistentCache(url, fetchOptions) : this.fetchAndAddToInternalCache(url, fetchOptions));\n    return this.cacheStore.get(url)?.content ?? \"\";\n  }\n  set(url, data) {\n    this.cacheStore.set(url, data);\n  }\n  isCached(url) {\n    return this.cacheStore.get(url)?.status === STATUS.LOADED;\n  }\n  async fetchAndAddToInternalCache(url, fetchOptions) {\n    const cache = this.cacheStore.get(url);\n    if (cache?.status === STATUS.LOADING) {\n      await this.handleLoading(url, async () => {\n        this.cacheStore.set(url, {\n          content: \"\",\n          status: STATUS.IDLE\n        });\n        await this.fetchAndAddToInternalCache(url, fetchOptions);\n      });\n      return;\n    }\n    if (!cache?.content) {\n      this.cacheStore.set(url, {\n        content: \"\",\n        status: STATUS.LOADING\n      });\n      try {\n        const content = await request(url, fetchOptions);\n        this.cacheStore.set(url, {\n          content,\n          status: STATUS.LOADED\n        });\n      } catch (error) {\n        this.cacheStore.set(url, {\n          content: \"\",\n          status: STATUS.FAILED\n        });\n        throw error;\n      }\n    }\n  }\n  async fetchAndAddToPersistentCache(url, fetchOptions) {\n    const cache = this.cacheStore.get(url);\n    if (cache?.status === STATUS.LOADED) {\n      return;\n    }\n    if (cache?.status === STATUS.LOADING) {\n      await this.handleLoading(url, async () => {\n        this.cacheStore.set(url, {\n          content: \"\",\n          status: STATUS.IDLE\n        });\n        await this.fetchAndAddToPersistentCache(url, fetchOptions);\n      });\n      return;\n    }\n    this.cacheStore.set(url, {\n      content: \"\",\n      status: STATUS.LOADING\n    });\n    const data = await this.cacheApi?.match(url);\n    if (data) {\n      const content = await data.text();\n      this.cacheStore.set(url, {\n        content,\n        status: STATUS.LOADED\n      });\n      return;\n    }\n    try {\n      await this.cacheApi?.add(new Request(url, fetchOptions));\n      const response = await this.cacheApi?.match(url);\n      const content = (await response?.text()) ?? \"\";\n      this.cacheStore.set(url, {\n        content,\n        status: STATUS.LOADED\n      });\n    } catch (error) {\n      this.cacheStore.set(url, {\n        content: \"\",\n        status: STATUS.FAILED\n      });\n      throw error;\n    }\n  }\n  async handleLoading(url, callback) {\n    for (let retryCount = 0; retryCount < CACHE_MAX_RETRIES; retryCount++) {\n      if (this.cacheStore.get(url)?.status !== STATUS.LOADING) {\n        return;\n      }\n      await sleep(0.1);\n    }\n    await callback();\n  }\n  keys() {\n    return [...this.cacheStore.keys()];\n  }\n  data() {\n    return [...this.cacheStore.entries()].map(([key, value]) => ({\n      [key]: value\n    }));\n  }\n  async delete(url) {\n    if (this.cacheApi) {\n      await this.cacheApi.delete(url);\n    }\n    this.cacheStore.delete(url);\n  }\n  async clear() {\n    if (this.cacheApi) {\n      const keys = await this.cacheApi.keys();\n      await Promise.allSettled(keys.map(key => this.cacheApi.delete(key)));\n    }\n    this.cacheStore.clear();\n  }\n};\n\n// src/modules/hooks.tsx\nimport { useEffect, useRef } from \"react\";\nfunction usePrevious(state) {\n  const ref = useRef(void 0);\n  useEffect(() => {\n    ref.current = state;\n  });\n  return ref.current;\n}\n\n// src/modules/utils.ts\nimport convert from \"react-from-dom\";\nfunction getNode(options) {\n  const {\n    baseURL,\n    content,\n    description,\n    handleError,\n    hash,\n    preProcessor,\n    title,\n    uniquifyIDs = false\n  } = options;\n  try {\n    const svgText = processSVG(content, preProcessor);\n    const node = convert(svgText, {\n      nodeOnly: true\n    });\n    if (!node || !(node instanceof SVGSVGElement)) {\n      throw new Error(\"Could not convert the src to a DOM Node\");\n    }\n    const svg = updateSVGAttributes(node, {\n      baseURL,\n      hash,\n      uniquifyIDs\n    });\n    if (description) {\n      const originalDesc = svg.querySelector(\"desc\");\n      if (originalDesc?.parentNode) {\n        originalDesc.parentNode.removeChild(originalDesc);\n      }\n      const descElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"desc\");\n      descElement.innerHTML = description;\n      svg.prepend(descElement);\n    }\n    if (typeof title !== \"undefined\") {\n      const originalTitle = svg.querySelector(\"title\");\n      if (originalTitle?.parentNode) {\n        originalTitle.parentNode.removeChild(originalTitle);\n      }\n      if (title) {\n        const titleElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"title\");\n        titleElement.innerHTML = title;\n        svg.prepend(titleElement);\n      }\n    }\n    return svg;\n  } catch (error) {\n    return handleError(error);\n  }\n}\nfunction processSVG(content, preProcessor) {\n  if (preProcessor) {\n    return preProcessor(content);\n  }\n  return content;\n}\nfunction updateSVGAttributes(node, options) {\n  const {\n    baseURL = \"\",\n    hash,\n    uniquifyIDs\n  } = options;\n  const replaceableAttributes = [\"id\", \"href\", \"xlink:href\", \"xlink:role\", \"xlink:arcrole\"];\n  const linkAttributes = [\"href\", \"xlink:href\"];\n  const isDataValue = (name, value) => linkAttributes.includes(name) && (value ? !value.includes(\"#\") : false);\n  if (!uniquifyIDs) {\n    return node;\n  }\n  [...node.children].forEach(d => {\n    if (d.attributes?.length) {\n      const attributes = Object.values(d.attributes).map(a => {\n        const attribute = a;\n        const match = /url\\((.*?)\\)/.exec(a.value);\n        if (match?.[1]) {\n          attribute.value = a.value.replace(match[0], `url(${baseURL}${match[1]}__${hash})`);\n        }\n        return attribute;\n      });\n      replaceableAttributes.forEach(r => {\n        const attribute = attributes.find(a => a.name === r);\n        if (attribute && !isDataValue(r, attribute.value)) {\n          attribute.value = `${attribute.value}__${hash}`;\n        }\n      });\n    }\n    if (d.children.length) {\n      return updateSVGAttributes(d, options);\n    }\n    return d;\n  });\n  return node;\n}\n\n// src/index.tsx\nvar cacheStore;\nfunction ReactInlineSVG(props) {\n  const {\n    cacheRequests = true,\n    children = null,\n    description,\n    fetchOptions,\n    innerRef,\n    loader = null,\n    onError,\n    onLoad,\n    src,\n    title,\n    uniqueHash\n  } = props;\n  const [state, setState] = useReducer((previousState2, nextState) => ({\n    ...previousState2,\n    ...nextState\n  }), {\n    content: \"\",\n    element: null,\n    isCached: cacheRequests && cacheStore.isCached(props.src),\n    status: STATUS.IDLE\n  });\n  const {\n    content,\n    element,\n    isCached,\n    status\n  } = state;\n  const previousProps = usePrevious(props);\n  const previousState = usePrevious(state);\n  const hash = useRef2(uniqueHash ?? randomString(8));\n  const isActive = useRef2(false);\n  const isInitialized = useRef2(false);\n  const handleError = useCallback(error => {\n    if (isActive.current) {\n      setState({\n        status: error.message === \"Browser does not support SVG\" ? STATUS.UNSUPPORTED : STATUS.FAILED\n      });\n      onError?.(error);\n    }\n  }, [onError]);\n  const handleLoad = useCallback((loadedContent, hasCache = false) => {\n    if (isActive.current) {\n      setState({\n        content: loadedContent,\n        isCached: hasCache,\n        status: STATUS.LOADED\n      });\n    }\n  }, []);\n  const fetchContent = useCallback(async () => {\n    const responseContent = await request(src, fetchOptions);\n    handleLoad(responseContent);\n  }, [fetchOptions, handleLoad, src]);\n  const getElement = useCallback(() => {\n    try {\n      const node = getNode({\n        ...props,\n        handleError,\n        hash: hash.current,\n        content\n      });\n      const convertedElement = convert2(node);\n      if (!convertedElement || !isValidElement(convertedElement)) {\n        throw new Error(\"Could not convert the src to a React element\");\n      }\n      setState({\n        element: convertedElement,\n        status: STATUS.READY\n      });\n    } catch (error) {\n      handleError(error);\n    }\n  }, [content, handleError, props]);\n  const getContent = useCallback(async () => {\n    const dataURI = /^data:image\\/svg[^,]*?(;base64)?,(.*)/u.exec(src);\n    let inlineSrc;\n    if (dataURI) {\n      inlineSrc = dataURI[1] ? window.atob(dataURI[2]) : decodeURIComponent(dataURI[2]);\n    } else if (src.includes(\"<svg\")) {\n      inlineSrc = src;\n    }\n    if (inlineSrc) {\n      handleLoad(inlineSrc);\n      return;\n    }\n    try {\n      if (cacheRequests) {\n        const cachedContent = await cacheStore.get(src, fetchOptions);\n        handleLoad(cachedContent, true);\n      } else {\n        await fetchContent();\n      }\n    } catch (error) {\n      handleError(error);\n    }\n  }, [cacheRequests, fetchContent, fetchOptions, handleError, handleLoad, src]);\n  const load = useCallback(async () => {\n    if (isActive.current) {\n      setState({\n        content: \"\",\n        element: null,\n        isCached: false,\n        status: STATUS.LOADING\n      });\n    }\n  }, []);\n  useEffect2(() => {\n    isActive.current = true;\n    if (!canUseDOM() || isInitialized.current) {\n      return void 0;\n    }\n    try {\n      if (status === STATUS.IDLE) {\n        if (!isSupportedEnvironment()) {\n          throw new Error(\"Browser does not support SVG\");\n        }\n        if (!src) {\n          throw new Error(\"Missing src\");\n        }\n        load();\n      }\n    } catch (error) {\n      handleError(error);\n    }\n    isInitialized.current = true;\n    return () => {\n      isActive.current = false;\n    };\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useEffect2(() => {\n    if (!canUseDOM() || !previousProps) {\n      return;\n    }\n    if (previousProps.src !== src) {\n      if (!src) {\n        handleError(new Error(\"Missing src\"));\n        return;\n      }\n      load();\n    }\n  }, [handleError, load, previousProps, src]);\n  useEffect2(() => {\n    if (status === STATUS.LOADED) {\n      getElement();\n    }\n  }, [status, getElement]);\n  useEffect2(() => {\n    if (!canUseDOM() || !previousProps || previousProps.src !== src) {\n      return;\n    }\n    if (previousProps.title !== title || previousProps.description !== description) {\n      getElement();\n    }\n  }, [description, getElement, previousProps, src, title]);\n  useEffect2(() => {\n    if (!previousState) {\n      return;\n    }\n    switch (status) {\n      case STATUS.LOADING:\n        {\n          if (previousState.status !== STATUS.LOADING) {\n            getContent();\n          }\n          break;\n        }\n      case STATUS.LOADED:\n        {\n          if (previousState.status !== STATUS.LOADED) {\n            getElement();\n          }\n          break;\n        }\n      case STATUS.READY:\n        {\n          if (previousState.status !== STATUS.READY) {\n            onLoad?.(src, isCached);\n          }\n          break;\n        }\n    }\n  }, [getContent, getElement, isCached, onLoad, previousState, src, status]);\n  const elementProps = omit(props, \"baseURL\", \"cacheRequests\", \"children\", \"description\", \"fetchOptions\", \"innerRef\", \"loader\", \"onError\", \"onLoad\", \"preProcessor\", \"src\", \"title\", \"uniqueHash\", \"uniquifyIDs\");\n  if (!canUseDOM()) {\n    return loader;\n  }\n  if (element) {\n    return cloneElement(element, {\n      ref: innerRef,\n      ...elementProps\n    });\n  }\n  if ([STATUS.UNSUPPORTED, STATUS.FAILED].includes(status)) {\n    return children;\n  }\n  return loader;\n}\nfunction InlineSVG(props) {\n  if (!cacheStore) {\n    cacheStore = new CacheStore();\n  }\n  const {\n    loader\n  } = props;\n  const [isReady, setReady] = useState(cacheStore.isReady);\n  useEffect2(() => {\n    if (isReady) {\n      return;\n    }\n    cacheStore.onReady(() => {\n      setReady(true);\n    });\n  }, [isReady]);\n  if (!isReady) {\n    return loader;\n  }\n  return /* @__PURE__ */React.createElement(ReactInlineSVG, {\n    ...props\n  });\n}\nexport { cacheStore, InlineSVG as default };","map":{"version":3,"names":["React","cloneElement","isValidElement","useCallback","useEffect","useEffect2","useReducer","useRef","useRef2","useState","convert2","CACHE_NAME","CACHE_MAX_RETRIES","STATUS","IDLE","LOADING","LOADED","FAILED","READY","UNSUPPORTED","randomCharacter","character","Math","floor","random","length","canUseDOM","window","document","createElement","isSupportedEnvironment","supportsInlineSVG","omit","input","filter","output","key","hasOwnProperty","call","includes","randomString","letters","numbers","charset","toUpperCase","R","index","request","url","options","response","fetch","contentType","headers","get","fileType","split","status","Error","some","d","text","sleep","seconds","Promise","resolve","setTimeout","div","innerHTML","svg","firstChild","namespaceURI","CacheStore","constructor","__publicField","cacheStore","Map","cacheName","usePersistentCache","REACT_INLINESVG_CACHE_NAME","REACT_INLINESVG_PERSISTENT_CACHE","caches","open","then","cache","cacheApi","catch","error","console","message","finally","isReady","callbacks","subscribers","forEach","callback","onReady","push","fetchOptions","fetchAndAddToPersistentCache","fetchAndAddToInternalCache","content","set","data","isCached","handleLoading","match","add","Request","retryCount","keys","entries","map","value","delete","clear","allSettled","usePrevious","state","ref","current","convert","getNode","baseURL","description","handleError","hash","preProcessor","title","uniquifyIDs","svgText","processSVG","node","nodeOnly","SVGSVGElement","updateSVGAttributes","originalDesc","querySelector","parentNode","removeChild","descElement","createElementNS","prepend","originalTitle","titleElement","replaceableAttributes","linkAttributes","isDataValue","name","children","attributes","Object","values","a","attribute","exec","replace","r","find","ReactInlineSVG","props","cacheRequests","innerRef","loader","onError","onLoad","src","uniqueHash","setState","previousState2","nextState","element","previousProps","previousState","isActive","isInitialized","handleLoad","loadedContent","hasCache","fetchContent","responseContent","getElement","convertedElement","getContent","dataURI","inlineSrc","atob","decodeURIComponent","cachedContent","load","elementProps","InlineSVG","setReady"],"sources":["/Users/ankish/Downloads/MA/MAPIT/untitledUi/node_modules/react-inlinesvg/src/index.tsx","/Users/ankish/Downloads/MA/MAPIT/untitledUi/node_modules/react-inlinesvg/src/config.ts","/Users/ankish/Downloads/MA/MAPIT/untitledUi/node_modules/react-inlinesvg/src/modules/helpers.ts","/Users/ankish/Downloads/MA/MAPIT/untitledUi/node_modules/react-inlinesvg/src/modules/cache.ts","/Users/ankish/Downloads/MA/MAPIT/untitledUi/node_modules/react-inlinesvg/src/modules/hooks.tsx","/Users/ankish/Downloads/MA/MAPIT/untitledUi/node_modules/react-inlinesvg/src/modules/utils.ts"],"sourcesContent":["import React, {\n  cloneElement,\n  isValidElement,\n  ReactElement,\n  useCallback,\n  useEffect,\n  useReducer,\n  useRef,\n  useState,\n} from 'react';\nimport convert from 'react-from-dom';\n\nimport { STATUS } from './config';\nimport CacheStore from './modules/cache';\nimport { canUseDOM, isSupportedEnvironment, omit, randomString, request } from './modules/helpers';\nimport { usePrevious } from './modules/hooks';\nimport { getNode } from './modules/utils';\nimport { FetchError, Props, State, Status } from './types';\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let cacheStore: CacheStore;\n\nfunction ReactInlineSVG(props: Props) {\n  const {\n    cacheRequests = true,\n    children = null,\n    description,\n    fetchOptions,\n    innerRef,\n    loader = null,\n    onError,\n    onLoad,\n    src,\n    title,\n    uniqueHash,\n  } = props;\n  const [state, setState] = useReducer(\n    (previousState: State, nextState: Partial<State>) => ({\n      ...previousState,\n      ...nextState,\n    }),\n    {\n      content: '',\n      element: null,\n\n      isCached: cacheRequests && cacheStore.isCached(props.src),\n      status: STATUS.IDLE,\n    },\n  );\n  const { content, element, isCached, status } = state;\n  const previousProps = usePrevious(props);\n  const previousState = usePrevious(state);\n\n  const hash = useRef(uniqueHash ?? randomString(8));\n  const isActive = useRef(false);\n  const isInitialized = useRef(false);\n\n  const handleError = useCallback(\n    (error: Error | FetchError) => {\n      if (isActive.current) {\n        setState({\n          status:\n            error.message === 'Browser does not support SVG' ? STATUS.UNSUPPORTED : STATUS.FAILED,\n        });\n\n        onError?.(error);\n      }\n    },\n    [onError],\n  );\n\n  const handleLoad = useCallback((loadedContent: string, hasCache = false) => {\n    if (isActive.current) {\n      setState({\n        content: loadedContent,\n        isCached: hasCache,\n        status: STATUS.LOADED,\n      });\n    }\n  }, []);\n\n  const fetchContent = useCallback(async () => {\n    const responseContent: string = await request(src, fetchOptions);\n\n    handleLoad(responseContent);\n  }, [fetchOptions, handleLoad, src]);\n\n  const getElement = useCallback(() => {\n    try {\n      const node = getNode({ ...props, handleError, hash: hash.current, content }) as Node;\n      const convertedElement = convert(node);\n\n      if (!convertedElement || !isValidElement(convertedElement)) {\n        throw new Error('Could not convert the src to a React element');\n      }\n\n      setState({\n        element: convertedElement,\n        status: STATUS.READY,\n      });\n    } catch (error: any) {\n      handleError(error);\n    }\n  }, [content, handleError, props]);\n\n  const getContent = useCallback(async () => {\n    const dataURI = /^data:image\\/svg[^,]*?(;base64)?,(.*)/u.exec(src);\n    let inlineSrc;\n\n    if (dataURI) {\n      inlineSrc = dataURI[1] ? window.atob(dataURI[2]) : decodeURIComponent(dataURI[2]);\n    } else if (src.includes('<svg')) {\n      inlineSrc = src;\n    }\n\n    if (inlineSrc) {\n      handleLoad(inlineSrc);\n\n      return;\n    }\n\n    try {\n      if (cacheRequests) {\n        const cachedContent = await cacheStore.get(src, fetchOptions);\n\n        handleLoad(cachedContent, true);\n      } else {\n        await fetchContent();\n      }\n    } catch (error: any) {\n      handleError(error);\n    }\n  }, [cacheRequests, fetchContent, fetchOptions, handleError, handleLoad, src]);\n\n  const load = useCallback(async () => {\n    if (isActive.current) {\n      setState({\n        content: '',\n        element: null,\n        isCached: false,\n        status: STATUS.LOADING,\n      });\n    }\n  }, []);\n\n  // Run on mount\n  useEffect(\n    () => {\n      isActive.current = true;\n\n      if (!canUseDOM() || isInitialized.current) {\n        return undefined;\n      }\n\n      try {\n        if (status === STATUS.IDLE) {\n          if (!isSupportedEnvironment()) {\n            throw new Error('Browser does not support SVG');\n          }\n\n          if (!src) {\n            throw new Error('Missing src');\n          }\n\n          load();\n        }\n      } catch (error: any) {\n        handleError(error);\n      }\n\n      isInitialized.current = true;\n\n      return () => {\n        isActive.current = false;\n      };\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [],\n  );\n\n  // Handles `src` changes\n  useEffect(() => {\n    if (!canUseDOM() || !previousProps) {\n      return;\n    }\n\n    if (previousProps.src !== src) {\n      if (!src) {\n        handleError(new Error('Missing src'));\n\n        return;\n      }\n\n      load();\n    }\n  }, [handleError, load, previousProps, src]);\n\n  // Handles content loading\n  useEffect(() => {\n    if (status === STATUS.LOADED) {\n      getElement();\n    }\n  }, [status, getElement]);\n\n  // Handles `title` and `description` changes\n  useEffect(() => {\n    if (!canUseDOM() || !previousProps || previousProps.src !== src) {\n      return;\n    }\n\n    if (previousProps.title !== title || previousProps.description !== description) {\n      getElement();\n    }\n  }, [description, getElement, previousProps, src, title]);\n\n  // handle state\n  useEffect(() => {\n    if (!previousState) {\n      return;\n    }\n\n    switch (status) {\n      case STATUS.LOADING: {\n        if (previousState.status !== STATUS.LOADING) {\n          getContent();\n        }\n\n        break;\n      }\n      case STATUS.LOADED: {\n        if (previousState.status !== STATUS.LOADED) {\n          getElement();\n        }\n\n        break;\n      }\n      case STATUS.READY: {\n        if (previousState.status !== STATUS.READY) {\n          onLoad?.(src, isCached);\n        }\n\n        break;\n      }\n    }\n  }, [getContent, getElement, isCached, onLoad, previousState, src, status]);\n\n  const elementProps = omit(\n    props,\n    'baseURL',\n    'cacheRequests',\n    'children',\n    'description',\n    'fetchOptions',\n    'innerRef',\n    'loader',\n    'onError',\n    'onLoad',\n    'preProcessor',\n    'src',\n    'title',\n    'uniqueHash',\n    'uniquifyIDs',\n  );\n\n  if (!canUseDOM()) {\n    return loader;\n  }\n\n  if (element) {\n    return cloneElement(element as ReactElement, {\n      ref: innerRef,\n      ...elementProps,\n    });\n  }\n\n  if (([STATUS.UNSUPPORTED, STATUS.FAILED] as Status[]).includes(status)) {\n    return children;\n  }\n\n  return loader;\n}\n\nexport default function InlineSVG(props: Props) {\n  if (!cacheStore) {\n    cacheStore = new CacheStore();\n  }\n\n  const { loader } = props;\n  const [isReady, setReady] = useState(cacheStore.isReady);\n\n  useEffect(() => {\n    if (isReady) {\n      return;\n    }\n\n    cacheStore.onReady(() => {\n      setReady(true);\n    });\n  }, [isReady]);\n\n  if (!isReady) {\n    return loader;\n  }\n\n  return <ReactInlineSVG {...props} />;\n}\n\nexport * from './types';\n","export const CACHE_NAME = 'react-inlinesvg';\nexport const CACHE_MAX_RETRIES = 10;\n\nexport const STATUS = {\n  IDLE: 'idle',\n  LOADING: 'loading',\n  LOADED: 'loaded',\n  FAILED: 'failed',\n  READY: 'ready',\n  UNSUPPORTED: 'unsupported',\n} as const;\n","import type { PlainObject } from '../types';\n\nfunction randomCharacter(character: string) {\n  return character[Math.floor(Math.random() * character.length)];\n}\n\nexport function canUseDOM(): boolean {\n  return !!(typeof window !== 'undefined' && window.document?.createElement);\n}\n\nexport function isSupportedEnvironment(): boolean {\n  return supportsInlineSVG() && typeof window !== 'undefined' && window !== null;\n}\n\n/**\n *  Remove properties from an object\n */\nexport function omit<T extends PlainObject, K extends keyof T>(\n  input: T,\n  ...filter: K[]\n): Omit<T, K> {\n  const output: any = {};\n\n  for (const key in input) {\n    if ({}.hasOwnProperty.call(input, key)) {\n      if (!filter.includes(key as unknown as K)) {\n        output[key] = input[key];\n      }\n    }\n  }\n\n  return output as Omit<T, K>;\n}\n\nexport function randomString(length: number): string {\n  const letters = 'abcdefghijklmnopqrstuvwxyz';\n  const numbers = '1234567890';\n  const charset = `${letters}${letters.toUpperCase()}${numbers}`;\n\n  let R = '';\n\n  for (let index = 0; index < length; index++) {\n    R += randomCharacter(charset);\n  }\n\n  return R;\n}\n\nexport async function request(url: string, options?: RequestInit) {\n  const response = await fetch(url, options);\n  const contentType = response.headers.get('content-type');\n  const [fileType] = (contentType ?? '').split(/ ?; ?/);\n\n  if (response.status > 299) {\n    throw new Error('Not found');\n  }\n\n  if (!['image/svg+xml', 'text/plain'].some(d => fileType.includes(d))) {\n    throw new Error(`Content type isn't valid: ${fileType}`);\n  }\n\n  return response.text();\n}\n\nexport function sleep(seconds = 1) {\n  return new Promise(resolve => {\n    setTimeout(resolve, seconds * 1000);\n  });\n}\n\nexport function supportsInlineSVG(): boolean {\n  /* c8 ignore next 3 */\n  if (!document) {\n    return false;\n  }\n\n  const div = document.createElement('div');\n\n  div.innerHTML = '<svg />';\n  const svg = div.firstChild as SVGSVGElement;\n\n  return !!svg && svg.namespaceURI === 'http://www.w3.org/2000/svg';\n}\n","import { CACHE_MAX_RETRIES, CACHE_NAME, STATUS } from '../config';\nimport { StorageItem } from '../types';\n\nimport { canUseDOM, request, sleep } from './helpers';\n\nexport default class CacheStore {\n  private cacheApi: Cache | undefined;\n  private readonly cacheStore: Map<string, StorageItem>;\n  private readonly subscribers: Array<() => void> = [];\n  public isReady = false;\n\n  constructor() {\n    this.cacheStore = new Map<string, StorageItem>();\n\n    let cacheName = CACHE_NAME;\n    let usePersistentCache = false;\n\n    if (canUseDOM()) {\n      cacheName = window.REACT_INLINESVG_CACHE_NAME ?? CACHE_NAME;\n      usePersistentCache = !!window.REACT_INLINESVG_PERSISTENT_CACHE && 'caches' in window;\n    }\n\n    if (usePersistentCache) {\n      caches\n        .open(cacheName)\n        .then(cache => {\n          this.cacheApi = cache;\n        })\n        .catch(error => {\n          // eslint-disable-next-line no-console\n          console.error(`Failed to open cache: ${error.message}`);\n          this.cacheApi = undefined;\n        })\n        .finally(() => {\n          this.isReady = true;\n          // Copy to avoid mutation issues\n          const callbacks = [...this.subscribers];\n\n          // Clear array efficiently\n          this.subscribers.length = 0;\n\n          callbacks.forEach(callback => {\n            try {\n              callback();\n            } catch (error: any) {\n              // eslint-disable-next-line no-console\n              console.error(`Error in CacheStore subscriber callback: ${error.message}`);\n            }\n          });\n        });\n    } else {\n      this.isReady = true;\n    }\n  }\n\n  public onReady(callback: () => void) {\n    if (this.isReady) {\n      callback();\n    } else {\n      this.subscribers.push(callback);\n    }\n  }\n\n  public async get(url: string, fetchOptions?: RequestInit) {\n    await (this.cacheApi\n      ? this.fetchAndAddToPersistentCache(url, fetchOptions)\n      : this.fetchAndAddToInternalCache(url, fetchOptions));\n\n    return this.cacheStore.get(url)?.content ?? '';\n  }\n\n  public set(url: string, data: StorageItem) {\n    this.cacheStore.set(url, data);\n  }\n\n  public isCached(url: string) {\n    return this.cacheStore.get(url)?.status === STATUS.LOADED;\n  }\n\n  private async fetchAndAddToInternalCache(url: string, fetchOptions?: RequestInit) {\n    const cache = this.cacheStore.get(url);\n\n    if (cache?.status === STATUS.LOADING) {\n      await this.handleLoading(url, async () => {\n        this.cacheStore.set(url, { content: '', status: STATUS.IDLE });\n        await this.fetchAndAddToInternalCache(url, fetchOptions);\n      });\n\n      return;\n    }\n\n    if (!cache?.content) {\n      this.cacheStore.set(url, { content: '', status: STATUS.LOADING });\n\n      try {\n        const content = await request(url, fetchOptions);\n\n        this.cacheStore.set(url, { content, status: STATUS.LOADED });\n      } catch (error: any) {\n        this.cacheStore.set(url, { content: '', status: STATUS.FAILED });\n        throw error;\n      }\n    }\n  }\n\n  private async fetchAndAddToPersistentCache(url: string, fetchOptions?: RequestInit) {\n    const cache = this.cacheStore.get(url);\n\n    if (cache?.status === STATUS.LOADED) {\n      return;\n    }\n\n    if (cache?.status === STATUS.LOADING) {\n      await this.handleLoading(url, async () => {\n        this.cacheStore.set(url, { content: '', status: STATUS.IDLE });\n        await this.fetchAndAddToPersistentCache(url, fetchOptions);\n      });\n\n      return;\n    }\n\n    this.cacheStore.set(url, { content: '', status: STATUS.LOADING });\n\n    const data = await this.cacheApi?.match(url);\n\n    if (data) {\n      const content = await data.text();\n\n      this.cacheStore.set(url, { content, status: STATUS.LOADED });\n\n      return;\n    }\n\n    try {\n      await this.cacheApi?.add(new Request(url, fetchOptions));\n\n      const response = await this.cacheApi?.match(url);\n      const content = (await response?.text()) ?? '';\n\n      this.cacheStore.set(url, { content, status: STATUS.LOADED });\n    } catch (error: any) {\n      this.cacheStore.set(url, { content: '', status: STATUS.FAILED });\n      throw error;\n    }\n  }\n\n  private async handleLoading(url: string, callback: () => Promise<void>) {\n    for (let retryCount = 0; retryCount < CACHE_MAX_RETRIES; retryCount++) {\n      if (this.cacheStore.get(url)?.status !== STATUS.LOADING) {\n        return;\n      }\n\n      // eslint-disable-next-line no-await-in-loop\n      await sleep(0.1);\n    }\n\n    await callback();\n  }\n\n  public keys(): Array<string> {\n    return [...this.cacheStore.keys()];\n  }\n\n  public data(): Array<Record<string, StorageItem>> {\n    return [...this.cacheStore.entries()].map(([key, value]) => ({ [key]: value }));\n  }\n\n  public async delete(url: string) {\n    if (this.cacheApi) {\n      await this.cacheApi.delete(url);\n    }\n\n    this.cacheStore.delete(url);\n  }\n\n  public async clear() {\n    if (this.cacheApi) {\n      const keys = await this.cacheApi.keys();\n\n      await Promise.allSettled(keys.map(key => this.cacheApi!.delete(key)));\n    }\n\n    this.cacheStore.clear();\n  }\n}\n","import { useEffect, useRef } from 'react';\n\nexport function usePrevious<T>(state: T): T | undefined {\n  const ref = useRef<T>(undefined);\n\n  useEffect(() => {\n    ref.current = state;\n  });\n\n  return ref.current;\n}\n","import convert from 'react-from-dom';\n\nimport { Props, State } from '../types';\n\ninterface GetNodeOptions extends Props, Pick<State, 'content'> {\n  handleError: (error: Error) => void;\n  hash: string;\n}\n\ninterface UpdateSVGAttributesOptions extends Pick<Props, 'baseURL' | 'uniquifyIDs'> {\n  hash: string;\n}\n\nexport function getNode(options: GetNodeOptions) {\n  const {\n    baseURL,\n    content,\n    description,\n    handleError,\n    hash,\n    preProcessor,\n    title,\n    uniquifyIDs = false,\n  } = options;\n\n  try {\n    const svgText = processSVG(content, preProcessor);\n    const node = convert(svgText, { nodeOnly: true });\n\n    if (!node || !(node instanceof SVGSVGElement)) {\n      throw new Error('Could not convert the src to a DOM Node');\n    }\n\n    const svg = updateSVGAttributes(node, { baseURL, hash, uniquifyIDs });\n\n    if (description) {\n      const originalDesc = svg.querySelector('desc');\n\n      if (originalDesc?.parentNode) {\n        originalDesc.parentNode.removeChild(originalDesc);\n      }\n\n      const descElement = document.createElementNS('http://www.w3.org/2000/svg', 'desc');\n\n      descElement.innerHTML = description;\n      svg.prepend(descElement);\n    }\n\n    if (typeof title !== 'undefined') {\n      const originalTitle = svg.querySelector('title');\n\n      if (originalTitle?.parentNode) {\n        originalTitle.parentNode.removeChild(originalTitle);\n      }\n\n      if (title) {\n        const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'title');\n\n        titleElement.innerHTML = title;\n        svg.prepend(titleElement);\n      }\n    }\n\n    return svg;\n  } catch (error: any) {\n    return handleError(error);\n  }\n}\n\nexport function processSVG(content: string, preProcessor?: Props['preProcessor']) {\n  if (preProcessor) {\n    return preProcessor(content);\n  }\n\n  return content;\n}\n\nexport function updateSVGAttributes(\n  node: SVGSVGElement,\n  options: UpdateSVGAttributesOptions,\n): SVGSVGElement {\n  const { baseURL = '', hash, uniquifyIDs } = options;\n  const replaceableAttributes = ['id', 'href', 'xlink:href', 'xlink:role', 'xlink:arcrole'];\n  const linkAttributes = ['href', 'xlink:href'];\n  const isDataValue = (name: string, value: string) =>\n    linkAttributes.includes(name) && (value ? !value.includes('#') : false);\n\n  if (!uniquifyIDs) {\n    return node;\n  }\n\n  [...node.children].forEach(d => {\n    if (d.attributes?.length) {\n      const attributes = Object.values(d.attributes).map(a => {\n        const attribute = a;\n        const match = /url\\((.*?)\\)/.exec(a.value);\n\n        if (match?.[1]) {\n          attribute.value = a.value.replace(match[0], `url(${baseURL}${match[1]}__${hash})`);\n        }\n\n        return attribute;\n      });\n\n      replaceableAttributes.forEach(r => {\n        const attribute = attributes.find(a => a.name === r);\n\n        if (attribute && !isDataValue(r, attribute.value)) {\n          attribute.value = `${attribute.value}__${hash}`;\n        }\n      });\n    }\n\n    if (d.children.length) {\n      return updateSVGAttributes(d as SVGSVGElement, options);\n    }\n\n    return d;\n  });\n\n  return node;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}