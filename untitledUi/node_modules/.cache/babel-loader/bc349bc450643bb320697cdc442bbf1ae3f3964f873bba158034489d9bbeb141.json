{"ast":null,"code":"import { slicedToArray as n } from \"../../../_virtual/_rollupPluginBabelHelpers.js\";\nimport { useState as e, useRef as i, useContext as o, useEffect as t, useCallback as r } from \"react\";\nimport { GridKeyboardNavigationContext as a } from \"../../components/GridKeyboardNavigationContext/GridKeyboardNavigationContext.js\";\nimport u from \"../useFullKeyboardListeners.js\";\nimport c from \"../useEventListener/index.js\";\nimport { getActiveIndexFromInboundNavigation as s, calcActiveIndexAfterArrowNavigation as d } from \"./gridKeyboardNavigationHelper.js\";\nimport { useLastNavigationDirection as l } from \"../../components/Menu/Menu/hooks/useLastNavigationDirection.js\";\nvar f = -1;\nfunction v(v) {\n  var m = v.ref,\n    b = v.itemsCount,\n    I = v.numberOfItemsInLine,\n    g = v.onItemClicked,\n    p = v.entryFocusStrategy,\n    x = void 0 === p ? \"directional\" : p,\n    N = v.getItemByIndex,\n    y = void 0 === N ? function (n) {} : N,\n    O = v.focusOnMount,\n    j = void 0 !== O && O,\n    C = v.focusItemIndexOnMount,\n    L = void 0 === C ? f : C,\n    k = v.disabledIndexes,\n    K = void 0 === k ? [] : k,\n    M = v.circularNavigation,\n    A = void 0 !== M && M,\n    S = e(j && L !== f),\n    h = n(S, 2),\n    w = h[0],\n    B = h[1],\n    D = i(!1),\n    E = e(w ? L : f),\n    F = n(E, 2),\n    G = F[0],\n    H = F[1],\n    _ = e(!0),\n    P = n(_, 2),\n    R = P[0],\n    T = P[1],\n    q = o(a);\n  t(function () {\n    D.current ? B(!1) : D.current = !0;\n  }, [G]);\n  var z = r(function () {\n      var n;\n      return null === (n = m.current) || void 0 === n ? void 0 : n.blur();\n    }, [m]),\n    J = l().lastNavigationDirectionRef,\n    Q = r(function () {\n      if (G === f) {\n        var n = J.current;\n        H(\"directional\" === x && n ? s({\n          direction: n,\n          numberOfItemsInLine: I,\n          itemsCount: b\n        }) : 0), T(!0);\n      } else T(!0);\n    }, [G, x, b, J, I, H, T]),\n    U = r(function () {\n      T(!1);\n    }, [T]),\n    V = r(function () {\n      T(!0), H(f);\n    }, [H]);\n  c({\n    eventName: \"focus\",\n    callback: Q,\n    ref: m\n  }), c({\n    eventName: \"mousedown\",\n    callback: U,\n    ref: m\n  }), c({\n    eventName: \"blur\",\n    callback: V,\n    ref: m\n  }), t(function () {\n    var n;\n    G > -1 && (null === (n = m.current) || void 0 === n || n.focus());\n  }, [G, m]);\n  var W = r(function (n) {\n      T(arguments.length > 1 && void 0 !== arguments[1] && arguments[1]), H(n), g(y(n), n);\n    }, [H, g, y]),\n    X = r(function () {\n      if (R) return W(G, !0);\n    }, [R, W, G]);\n  return u({\n    ref: m,\n    onSelectionKey: X,\n    onArrowNavigation: function (n) {\n      if (T(!0), G !== f) {\n        var e = d({\n            activeIndex: G,\n            itemsCount: b,\n            numberOfItemsInLine: I,\n            direction: n,\n            disabledIndexes: K,\n            circularNavigation: A\n          }),\n          i = e.nextIndex;\n        e.isOutbound ? null == q || q.onOutboundNavigation(m, n) : H(i);\n      } else H(0);\n    },\n    onEscape: z,\n    focusOnMount: j\n  }), {\n    activeIndex: R ? G : f,\n    onSelectionAction: W,\n    isInitialActiveState: w\n  };\n}\nexport { v as default };","map":{"version":3,"names":["f","v","m","ref","b","itemsCount","I","numberOfItemsInLine","g","onItemClicked","p","entryFocusStrategy","x","N","getItemByIndex","y","n","O","focusOnMount","j","C","focusItemIndexOnMount","L","k","disabledIndexes","K","M","circularNavigation","A","S","e","h","w","B","D","i","E","F","G","H","_","P","R","T","q","o","a","t","current","z","r","blur","J","l","lastNavigationDirectionRef","Q","s","direction","U","V","c","eventName","callback","focus","W","arguments","length","X","u","onSelectionKey","onArrowNavigation","d","activeIndex","nextIndex","isOutbound","onOutboundNavigation","onEscape","onSelectionAction","isInitialActiveState","default"],"sources":["/Users/ankish/Downloads/MA/MAPIT/untitledUi/node_modules/@vibe/core/src/hooks/useGridKeyboardNavigation/useGridKeyboardNavigation.ts"],"sourcesContent":["import { MutableRefObject, ReactElement, useCallback, useContext, useEffect, useRef, useState } from \"react\";\nimport { GridKeyboardNavigationContext } from \"../../components/GridKeyboardNavigationContext/GridKeyboardNavigationContext\";\nimport useFullKeyboardListeners, { NavDirections } from \"../../hooks/useFullKeyboardListeners\";\nimport useEventListener from \"../../hooks/useEventListener\";\nimport {\n  calcActiveIndexAfterArrowNavigation,\n  getActiveIndexFromInboundNavigation\n} from \"./gridKeyboardNavigationHelper\";\nimport { useLastNavigationDirection } from \"../../components/Menu/Menu/hooks/useLastNavigationDirection\";\n\nconst NO_ACTIVE_INDEX = -1;\n\n/**\n * A hook which is used for accessible keyboard navigation. Useful for components rendering a list of items that can be navigated and selected with a keyboard.\n * @param {Object} options\n * @param {React.MutableRefObject} options.ref - the reference for the component that listens to keyboard\n * @param {number} options.itemsCount - the number of items\n * @param {number} options.numberOfItemsInLine - the number of items on each line of the grid\n * @param {function} options.onItemClicked - the callback for selecting an item. It will be called when an active item is selected, for example with \"Enter\".\n * @param {function} options.getItemByIndex - a function which gets an index as a param, and returns the item on that index\n * @param {\"directional\" | \"first\"} options.entryFocusStrategy - Determines how the first item is focused when entering the grid via keyboard.\n *   - \"directional\": Tries to focus based on the entry direction (Tab vs Shift+Tab). This is the default.\n *   - \"first\": Always focuses the first item.\n * @param {boolean=} options.focusOnMount - if true, the referenced element will be focused when mounted\n * @param {number=} options.focusItemIndexOnMount - optional item index to focus when mounted. Only works with \"options.focusOnMount\".\n * @param {number[]=} options.disabledIndexes - optional array of disabled indices, which will be skipped while navigating.\n * @param {boolean=} options.circularNavigation - if true, the navigation will wrap around the grid\n * @returns {useGridKeyboardNavigationResult}\n *\n * @typedef useGridKeyboardNavigationResult\n * @property {number} activeIndex - the currently active index\n * @property {boolean} isInitialActiveState - if true, the currently active element was due to an initial mounting index option. See \"options.focusItemIndexOnMount\".\n * @property {(index: number, isKeyboardAction?: boolean) => void} onSelectionAction - the callback which should be used to select an item.\n * It should be called with the selected item's index. Use this callback for onClick handlers, for example.\n * The \"isKeyboardAction\" can be used to indicate a keyboard selection, which will affect the currently active index.\n */\nexport default function useGridKeyboardNavigation({\n  ref,\n  itemsCount,\n  numberOfItemsInLine,\n  onItemClicked, // the callback to call when an item is selected\n  entryFocusStrategy = \"directional\",\n  getItemByIndex = (_index: number) => {},\n  focusOnMount = false,\n  focusItemIndexOnMount = NO_ACTIVE_INDEX,\n  disabledIndexes = [],\n  circularNavigation = false\n}: {\n  ref: MutableRefObject<HTMLElement>;\n  itemsCount: number;\n  numberOfItemsInLine: number;\n  onItemClicked: (element: HTMLElement | ReactElement | void | string, index: number) => void;\n  entryFocusStrategy?: \"directional\" | \"first\";\n  getItemByIndex: (index: number | void) => HTMLElement | ReactElement | void | string;\n  focusOnMount?: boolean;\n  focusItemIndexOnMount?: number;\n  disabledIndexes?: number[];\n  circularNavigation?: boolean;\n}) {\n  const [isInitialActiveState, setIsInitialActiveState] = useState(\n    focusOnMount && focusItemIndexOnMount !== NO_ACTIVE_INDEX\n  );\n  const skippedInitialActiveIndexChange = useRef(false);\n  const [activeIndex, setActiveIndex] = useState(isInitialActiveState ? focusItemIndexOnMount : NO_ACTIVE_INDEX);\n  const [isUsingKeyboardNav, setIsUsingKeyboardNav] = useState(true);\n\n  const keyboardContext = useContext(GridKeyboardNavigationContext);\n\n  const onArrowNavigation = (direction: NavDirections) => {\n    setIsUsingKeyboardNav(true);\n    if (activeIndex === NO_ACTIVE_INDEX) {\n      setActiveIndex(0);\n      return;\n    }\n\n    const { isOutbound, nextIndex } = calcActiveIndexAfterArrowNavigation({\n      activeIndex,\n      itemsCount,\n      numberOfItemsInLine,\n      direction,\n      disabledIndexes,\n      circularNavigation\n    });\n    if (isOutbound) {\n      keyboardContext?.onOutboundNavigation(ref, direction);\n    } else {\n      setActiveIndex(nextIndex);\n    }\n  };\n\n  useEffect(() => {\n    if (!skippedInitialActiveIndexChange.current) {\n      skippedInitialActiveIndexChange.current = true;\n      return;\n    }\n    // if the active state changes, this is no longer the initial active state\n    setIsInitialActiveState(false);\n  }, [activeIndex]);\n\n  const blurTargetElement = useCallback(() => ref.current?.blur(), [ref]);\n\n  const { lastNavigationDirectionRef } = useLastNavigationDirection();\n  const onFocus = useCallback(() => {\n    if (activeIndex !== NO_ACTIVE_INDEX) {\n      setIsUsingKeyboardNav(true);\n      return;\n    }\n\n    const direction = lastNavigationDirectionRef.current;\n    setActiveIndex(\n      entryFocusStrategy === \"directional\" && direction\n        ? getActiveIndexFromInboundNavigation({ direction, numberOfItemsInLine, itemsCount })\n        : 0\n    );\n    setIsUsingKeyboardNav(true);\n  }, [\n    activeIndex,\n    entryFocusStrategy,\n    itemsCount,\n    lastNavigationDirectionRef,\n    numberOfItemsInLine,\n    setActiveIndex,\n    setIsUsingKeyboardNav\n  ]);\n\n  const onMouseDown = useCallback(() => {\n    // If the user clicked on the grid element we assume that that what will caused the focus\n    setIsUsingKeyboardNav(false);\n  }, [setIsUsingKeyboardNav]);\n\n  const onBlur = useCallback(() => {\n    // If we lose focus we will return to isUsingKeyboardNav default mode which is that any interaction\n    // with the grid always done by keyboard, unless we clicked on the grid element before that with a mouse\n    setIsUsingKeyboardNav(true);\n    setActiveIndex(NO_ACTIVE_INDEX);\n  }, [setActiveIndex]);\n\n  useEventListener({ eventName: \"focus\", callback: onFocus, ref });\n  useEventListener({ eventName: \"mousedown\", callback: onMouseDown, ref });\n  useEventListener({ eventName: \"blur\", callback: onBlur, ref });\n\n  useEffect(() => {\n    if (activeIndex > -1) {\n      ref.current?.focus();\n    }\n  }, [activeIndex, ref]);\n\n  const onSelectionAction = useCallback(\n    (index: number, isKeyboardAction = false) => {\n      setIsUsingKeyboardNav(isKeyboardAction);\n      setActiveIndex(index);\n\n      onItemClicked(getItemByIndex(index), index);\n    },\n    [setActiveIndex, onItemClicked, getItemByIndex]\n  );\n\n  const onKeyboardSelection = useCallback(() => {\n    if (!isUsingKeyboardNav) {\n      return;\n    }\n    return onSelectionAction(activeIndex, true);\n  }, [isUsingKeyboardNav, onSelectionAction, activeIndex]);\n\n  useFullKeyboardListeners({\n    ref,\n    onSelectionKey: onKeyboardSelection,\n    onArrowNavigation,\n    onEscape: blurTargetElement,\n    focusOnMount\n  });\n\n  // if the user is not using keyboard nav, the consumers should not treat the index as active\n  const externalActiveIndex = isUsingKeyboardNav ? activeIndex : NO_ACTIVE_INDEX;\n  return {\n    activeIndex: externalActiveIndex,\n    onSelectionAction,\n    isInitialActiveState\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}