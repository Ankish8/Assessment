{"ast":null,"code":"import e, { useCallback as t } from \"react\";\nimport o from \"../../hooks/useKeyEvent/index.js\";\nimport r from \"../Flex/Flex.js\";\nimport i from \"../Avatar/Avatar.js\";\nimport n from \"../Clickable/ClickableWrapper.js\";\nimport a from \"./AvatarGroupCounterTooltipContent.module.scss.js\";\nimport l from \"../../hooks/useEventListener/index.js\";\nimport s from \"../../hooks/useListenFocusTriggers/index.js\";\nimport { AVATAR_GROUP_COUNTER_TOOLTIP_SHOW_DELAY as c, AVATAR_GROUP_COUNTER_AVATAR_SIZE as u } from \"./AvatarGroupConstants.js\";\nimport { keyCodes as f } from \"../../constants/keyCodes.js\";\nimport \"../../constants/sizes.js\";\nvar m = [f.TAB],\n  d = [f.ESCAPE];\nfunction p(e) {\n  var r = e.counterContainerRef,\n    i = void 0 === r ? void 0 : r,\n    n = e.tooltipContentContainerRef,\n    a = e.focusPrevPlaceholderRef,\n    u = e.focusNextPlaceholderRef,\n    f = e.isKeyboardTooltipVisible,\n    p = e.setIsKeyboardTooltipVisible,\n    v = t(function () {\n      f || setTimeout(function () {\n        return p(!0);\n      }, c);\n    }, [f, p]),\n    b = t(function () {\n      f && p(!1);\n    }, [f, p]);\n  s({\n    ref: i,\n    onFocusByKeyboard: v\n  }), l({\n    eventName: \"blur\",\n    ref: n,\n    callback: b\n  }), o({\n    keys: m,\n    ref: i,\n    withoutAnyModifier: !0,\n    preventDefault: !0,\n    callback: t(function () {\n      f && (null == n ? void 0 : n.current) && n.current.focus();\n    }, [f, n])\n  }), o({\n    keys: m,\n    modifier: o.modifiers.SHIFT,\n    ref: i,\n    callback: b\n  }), o({\n    keys: m,\n    ref: n,\n    withoutAnyModifier: !0,\n    callback: t(function () {\n      (null == u ? void 0 : u.current) && u.current.focus(), f && p(!1);\n    }, [u, f, p])\n  }), o({\n    keys: m,\n    ref: n,\n    modifier: o.modifiers.SHIFT,\n    callback: t(function () {\n      (null == a ? void 0 : a.current) && a.current.focus(), f && p(!1);\n    }, [a, f, p])\n  }), o({\n    keys: d,\n    ref: n,\n    callback: t(function () {\n      (null == i ? void 0 : i.current) && i.current.focus(), f && p(!1);\n    }, [i, f, p])\n  }), o({\n    keys: d,\n    ref: i,\n    callback: b\n  }), l({\n    eventName: \"focus\",\n    ref: u,\n    callback: b\n  });\n}\nvar v = function (t, o, l, s, c) {\n  var f = t.value,\n    m = Object.assign(Object.assign({}, l), {\n      width: c ? void 0 : \"100%\"\n    }),\n    d = \"tooltip-item-\".concat(o, \"-label\");\n  return e.createElement(n, {\n    key: o,\n    isClickable: !!(null == f ? void 0 : f.onClick),\n    clickableProps: {\n      onClick: function (e) {\n        return f.onClick(e, f.id);\n      },\n      tabIndex: \"-1\"\n    }\n  }, e.createElement(\"div\", {\n    style: m\n  }, e.createElement(r, {\n    direction: \"row\",\n    gap: \"xs\",\n    ariaLabelledby: d\n  }, e.createElement(i, Object.assign({}, f, {\n    tooltipProps: void 0,\n    ariaLabel: \"\",\n    customSize: u,\n    type: s || (null == f ? void 0 : f.type),\n    tabIndex: -1,\n    size: i.sizes.SMALL,\n    className: a.tooltipAvatarItemAvatar\n  })), !c && e.createElement(\"div\", {\n    id: d,\n    className: a.tooltipAvatarItemTitle\n  }, f.tooltipContent))));\n};\nexport { v as avatarRenderer, p as useTooltipContentTabNavigation };","map":{"version":3,"names":["m","f","TAB","d","ESCAPE","p","e","r","counterContainerRef","i","n","tooltipContentContainerRef","a","focusPrevPlaceholderRef","u","focusNextPlaceholderRef","isKeyboardTooltipVisible","setIsKeyboardTooltipVisible","v","t","setTimeout","c","b","s","ref","onFocusByKeyboard","l","eventName","callback","o","keys","withoutAnyModifier","preventDefault","current","focus","modifier","modifiers","SHIFT","avatarRenderer","value","Object","assign","width","concat","createElement","key","isClickable","onClick","clickableProps","id","tabIndex","style","direction","gap","ariaLabelledby","tooltipProps","ariaLabel","customSize","type","size","sizes","SMALL","className","tooltipAvatarItemAvatar","tooltipAvatarItemTitle","tooltipContent","useTooltipContentTabNavigation"],"sources":["/Users/ankish/Downloads/MA/MAPIT/untitledUi/node_modules/@vibe/core/src/components/AvatarGroup/AvatarGroupCounterTooltipHelper.tsx"],"sourcesContent":["import React, { CSSProperties, RefObject, useCallback } from \"react\";\nimport useKeyEvent from \"../../hooks/useKeyEvent\";\nimport Flex from \"../Flex/Flex\";\nimport Avatar, { AvatarProps } from \"../Avatar/Avatar\";\nimport ClickableWrapper from \"../Clickable/ClickableWrapper\";\nimport avatarGroupCounterTooltipContentStyles from \"./AvatarGroupCounterTooltipContent.module.scss\";\nimport useEventListener from \"../../hooks/useEventListener\";\nimport useListenFocusTriggers from \"../../hooks/useListenFocusTriggers\";\nimport { AvatarType } from \"../Avatar\";\nimport { ElementContent } from \"../../types\";\nimport { AVATAR_GROUP_COUNTER_AVATAR_SIZE, AVATAR_GROUP_COUNTER_TOOLTIP_SHOW_DELAY } from \"./AvatarGroupConstants\";\nimport { keyCodes } from \"../../constants\";\n\nconst TAB = [keyCodes.TAB];\nconst ESC = [keyCodes.ESCAPE];\n\nexport function useTooltipContentTabNavigation({\n  counterContainerRef = undefined,\n  tooltipContentContainerRef,\n  focusPrevPlaceholderRef,\n  focusNextPlaceholderRef,\n  isKeyboardTooltipVisible,\n  setIsKeyboardTooltipVisible\n}: {\n  counterContainerRef: RefObject<HTMLDivElement>;\n  tooltipContentContainerRef: RefObject<HTMLElement>;\n  focusPrevPlaceholderRef: RefObject<HTMLDivElement>;\n  focusNextPlaceholderRef: RefObject<HTMLDivElement>;\n  isKeyboardTooltipVisible: boolean;\n  setIsKeyboardTooltipVisible: (value: boolean) => void;\n}) {\n  const showKeyboardTooltip = useCallback(() => {\n    if (!isKeyboardTooltipVisible) {\n      // temp hack for display tooltip with delay after timeout because refactoring the tooltip with open mechanism is out of scope\n      setTimeout(() => setIsKeyboardTooltipVisible(true), AVATAR_GROUP_COUNTER_TOOLTIP_SHOW_DELAY);\n    }\n  }, [isKeyboardTooltipVisible, setIsKeyboardTooltipVisible]);\n\n  const hideKeyboardTooltip = useCallback(() => {\n    if (isKeyboardTooltipVisible) setIsKeyboardTooltipVisible(false);\n  }, [isKeyboardTooltipVisible, setIsKeyboardTooltipVisible]);\n\n  // Open tooltip manually when keyboard focusing on counter\n  useListenFocusTriggers({\n    ref: counterContainerRef,\n    onFocusByKeyboard: showKeyboardTooltip\n  });\n\n  useEventListener({\n    eventName: \"blur\",\n    ref: tooltipContentContainerRef,\n    callback: hideKeyboardTooltip\n  });\n\n  //Move focus to content by keyboard\n  useKeyEvent({\n    keys: TAB,\n    ref: counterContainerRef,\n    withoutAnyModifier: true,\n    preventDefault: true,\n    callback: useCallback(() => {\n      if (isKeyboardTooltipVisible) tooltipContentContainerRef?.current && tooltipContentContainerRef.current.focus();\n    }, [isKeyboardTooltipVisible, tooltipContentContainerRef])\n  });\n\n  // Close tooltip by keyboard\n  useKeyEvent({\n    keys: TAB,\n    modifier: useKeyEvent.modifiers.SHIFT,\n    ref: counterContainerRef,\n    callback: hideKeyboardTooltip\n  });\n  useKeyEvent({\n    keys: TAB,\n    ref: tooltipContentContainerRef,\n    withoutAnyModifier: true,\n    callback: useCallback(() => {\n      // We are not preventing default behaviour here and that's why after pressing tab and after moving focus to here\n      // the browser will move the focus to the next element in the focus order.\n      focusNextPlaceholderRef?.current && focusNextPlaceholderRef.current.focus();\n      if (isKeyboardTooltipVisible) setIsKeyboardTooltipVisible(false);\n    }, [focusNextPlaceholderRef, isKeyboardTooltipVisible, setIsKeyboardTooltipVisible])\n  });\n  useKeyEvent({\n    keys: TAB,\n    ref: tooltipContentContainerRef,\n    modifier: useKeyEvent.modifiers.SHIFT,\n    callback: useCallback(() => {\n      // We are not preventing default behaviour here and that's why after pressing tab and after moving focus to here\n      // the browser will move the focus to the next element in the focus order.\n      focusPrevPlaceholderRef?.current && focusPrevPlaceholderRef.current.focus();\n      if (isKeyboardTooltipVisible) setIsKeyboardTooltipVisible(false);\n    }, [focusPrevPlaceholderRef, isKeyboardTooltipVisible, setIsKeyboardTooltipVisible])\n  });\n  useKeyEvent({\n    keys: ESC,\n    ref: tooltipContentContainerRef,\n    callback: useCallback(() => {\n      counterContainerRef?.current && counterContainerRef.current.focus();\n      if (isKeyboardTooltipVisible) setIsKeyboardTooltipVisible(false);\n    }, [counterContainerRef, isKeyboardTooltipVisible, setIsKeyboardTooltipVisible])\n  });\n  useKeyEvent({\n    keys: ESC,\n    ref: counterContainerRef,\n    callback: hideKeyboardTooltip\n  });\n\n  // Close tooltip when moving focus to next element\n  useEventListener({\n    eventName: \"focus\",\n    ref: focusNextPlaceholderRef,\n    callback: hideKeyboardTooltip\n  });\n}\n\nexport const avatarRenderer = (\n  item: { value: AvatarProps & { tooltipContent: ElementContent } },\n  index: number,\n  style: CSSProperties,\n  type: AvatarType,\n  displayAsGrid: boolean\n) => {\n  const avatarProps = item.value;\n  const overrideStyle: CSSProperties = { ...style, width: displayAsGrid ? undefined : \"100%\" };\n  const labelId = `tooltip-item-${index}-label`;\n\n  return (\n    <ClickableWrapper\n      key={index}\n      isClickable={!!avatarProps?.onClick}\n      clickableProps={{ onClick: event => avatarProps.onClick(event, avatarProps.id), tabIndex: \"-1\" }}\n    >\n      <div style={overrideStyle}>\n        <Flex direction=\"row\" gap=\"xs\" ariaLabelledby={labelId}>\n          <Avatar\n            {...avatarProps}\n            tooltipProps={undefined}\n            ariaLabel={\"\"}\n            customSize={AVATAR_GROUP_COUNTER_AVATAR_SIZE}\n            type={type || avatarProps?.type}\n            tabIndex={-1}\n            size={Avatar.sizes.SMALL}\n            className={avatarGroupCounterTooltipContentStyles.tooltipAvatarItemAvatar}\n          />\n          {!displayAsGrid && (\n            <div id={labelId} className={avatarGroupCounterTooltipContentStyles.tooltipAvatarItemTitle}>\n              {avatarProps.tooltipContent}\n            </div>\n          )}\n        </Flex>\n      </div>\n    </ClickableWrapper>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}