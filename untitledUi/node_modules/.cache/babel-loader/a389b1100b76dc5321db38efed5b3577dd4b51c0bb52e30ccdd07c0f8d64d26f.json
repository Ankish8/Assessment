{"ast":null,"code":"import { NavDirections as n } from \"../useFullKeyboardListeners.js\";\nfunction e(e) {\n  var t = e.direction,\n    i = e.numberOfItemsInLine,\n    r = e.itemsCount,\n    u = function () {\n      var e = Math.floor(i / 2);\n      if (t === n.UP) return (Math.ceil(r / i) - 1) * i + e;\n      if (t === n.DOWN) return e;\n      if (t === n.LEFT) {\n        for (var u = i - 1, o = Math.floor((r - 1) / 2); o > u;) u += i;\n        return u;\n      }\n      if (t === n.RIGHT) {\n        for (var a = 0, c = Math.floor((r - 1) / 2); c > a + i;) a += i;\n        return a;\n      }\n    }();\n  return Math.max(0, Math.min(u, r - 1));\n}\nfunction t(e) {\n  var t = e.activeIndex,\n    i = e.itemsCount,\n    r = e.numberOfItemsInLine,\n    u = e.circularNavigation,\n    o = void 0 !== u && u,\n    a = function (n) {\n      return Math.ceil((n + 1) / r);\n    },\n    c = function (n) {\n      var e = t + (n ? 1 : -1);\n      if (0 > e || e >= i) {\n        if (!o) return {\n          isOutbound: !0\n        };\n        0 > e ? e = i - 1 : i > e || (e = 0);\n      }\n      return a(t) !== a(e) ? {\n        isOutbound: !0\n      } : {\n        isOutbound: !1,\n        nextIndex: e\n      };\n    },\n    s = function (n) {\n      var e = t + r * (n ? 1 : -1);\n      return 0 > e || e >= i ? {\n        isOutbound: !0\n      } : {\n        isOutbound: !1,\n        nextIndex: e\n      };\n    };\n  switch (e.direction) {\n    case n.RIGHT:\n      return c(!0);\n    case n.LEFT:\n      return c(!1);\n    case n.DOWN:\n      return s(!0);\n    case n.UP:\n      return s(!1);\n  }\n}\nfunction i(n) {\n  for (var e = n.itemsCount, i = n.numberOfItemsInLine, r = n.direction, u = n.disabledIndexes, o = void 0 === u ? [] : u, a = n.circularNavigation, c = void 0 !== a && a, s = t({\n      activeIndex: n.activeIndex,\n      itemsCount: e,\n      numberOfItemsInLine: i,\n      direction: r,\n      circularNavigation: c\n    }); !s.isOutbound && o.includes(s.nextIndex);) s = t({\n    activeIndex: s.nextIndex,\n    itemsCount: e,\n    numberOfItemsInLine: i,\n    direction: r,\n    circularNavigation: c\n  });\n  return s;\n}\nexport { i as calcActiveIndexAfterArrowNavigation, e as getActiveIndexFromInboundNavigation };","map":{"version":3,"names":["e","t","direction","i","numberOfItemsInLine","r","itemsCount","u","Math","floor","n","UP","ceil","DOWN","LEFT","o","RIGHT","a","c","max","min","activeIndex","circularNavigation","getIndexLine","horizontalChange","isOutbound","nextIndex","s","verticalChange","disabledIndexes","includes","calcActiveIndexAfterArrowNavigation","getActiveIndexFromInboundNavigation"],"sources":["/Users/ankish/Downloads/MA/MAPIT/untitledUi/node_modules/@vibe/core/src/hooks/useGridKeyboardNavigation/gridKeyboardNavigationHelper.ts"],"sourcesContent":["import { NavDirections } from \"../useFullKeyboardListeners\";\n\nexport function getActiveIndexFromInboundNavigation({\n  direction,\n  numberOfItemsInLine,\n  itemsCount\n}: {\n  direction: NavDirections;\n  numberOfItemsInLine: number;\n  itemsCount: number;\n}) {\n  const getRawIndex = () => {\n    const firstLineMiddleIndex = Math.floor(numberOfItemsInLine / 2);\n    if (direction === NavDirections.UP) {\n      // last line, middle\n      const rowCount = Math.ceil(itemsCount / numberOfItemsInLine);\n      return (rowCount - 1) * numberOfItemsInLine + firstLineMiddleIndex;\n    }\n    if (direction === NavDirections.DOWN) {\n      // first line, middle\n      return firstLineMiddleIndex;\n    }\n    if (direction === NavDirections.LEFT) {\n      // middle line, last item\n      let result = numberOfItemsInLine - 1;\n      const midIndex = Math.floor((itemsCount - 1) / 2);\n      while (result < midIndex) {\n        result += numberOfItemsInLine;\n      }\n      return result;\n    }\n    if (direction === NavDirections.RIGHT) {\n      // middle line, first item\n      let result = 0;\n      const midIndex = Math.floor((itemsCount - 1) / 2);\n      while (result + numberOfItemsInLine < midIndex) {\n        result += numberOfItemsInLine;\n      }\n      return result;\n    }\n  };\n\n  const rawIndex = getRawIndex();\n  return Math.max(0, Math.min(rawIndex, itemsCount - 1));\n}\n\nfunction calcRawNewIndexAfterArrowNavigation({\n  activeIndex,\n  itemsCount,\n  numberOfItemsInLine,\n  direction,\n  circularNavigation = false\n}: {\n  activeIndex: number;\n  itemsCount: number;\n  numberOfItemsInLine: number;\n  direction: NavDirections;\n  circularNavigation?: boolean;\n}) {\n  const getIndexLine = (index: number) => Math.ceil((index + 1) / numberOfItemsInLine);\n\n  const horizontalChange = (isIndexIncrease: boolean) => {\n    let nextIndex = activeIndex + (isIndexIncrease ? 1 : -1);\n\n    if (nextIndex < 0 || nextIndex >= itemsCount) {\n      if (circularNavigation) {\n        if (nextIndex < 0) {\n          nextIndex = itemsCount - 1;\n        } else if (nextIndex >= itemsCount) {\n          nextIndex = 0;\n        }\n      } else {\n        return { isOutbound: true };\n      }\n    }\n\n    const currentLine = getIndexLine(activeIndex);\n    const nextIndexLine = getIndexLine(nextIndex);\n    if (currentLine !== nextIndexLine) {\n      return { isOutbound: true };\n    }\n\n    return { isOutbound: false, nextIndex };\n  };\n\n  const verticalChange = (isIndexIncrease: boolean) => {\n    const nextIndex = activeIndex + numberOfItemsInLine * (isIndexIncrease ? 1 : -1);\n    if (nextIndex < 0 || itemsCount <= nextIndex) {\n      return { isOutbound: true };\n    }\n    return { isOutbound: false, nextIndex };\n  };\n\n  switch (direction) {\n    case NavDirections.RIGHT:\n      return horizontalChange(true);\n    case NavDirections.LEFT:\n      return horizontalChange(false);\n    case NavDirections.DOWN:\n      return verticalChange(true);\n    case NavDirections.UP:\n      return verticalChange(false);\n  }\n}\n\nexport function calcActiveIndexAfterArrowNavigation({\n  activeIndex,\n  itemsCount,\n  numberOfItemsInLine,\n  direction,\n  disabledIndexes = [],\n  circularNavigation = false\n}: {\n  activeIndex: number;\n  itemsCount: number;\n  numberOfItemsInLine: number;\n  direction: NavDirections;\n  disabledIndexes?: number[];\n  circularNavigation?: boolean;\n}) {\n  let result = calcRawNewIndexAfterArrowNavigation({\n    activeIndex,\n    itemsCount,\n    numberOfItemsInLine,\n    direction,\n    circularNavigation\n  });\n  while (!result.isOutbound && disabledIndexes.includes(result.nextIndex)) {\n    result = calcRawNewIndexAfterArrowNavigation({\n      activeIndex: result.nextIndex,\n      itemsCount,\n      numberOfItemsInLine,\n      direction,\n      circularNavigation\n    });\n  }\n\n  return result;\n}\n"],"mappings":";AAEM,SAAUA,EAAmCA,CAAA;EAQlD,IAPCC,CAAA,GAASD,CAAA,CAATE,SAAA;IACAC,CAAA,GAAmBH,CAAA,CAAnBI,mBAAA;IACAC,CAAA,GAAUL,CAAA,CAAVM,UAAA;IAqCMC,CAAA,GA/Bc;MAClB,IAAMP,CAAA,GAAuBQ,IAAA,CAAKC,KAAA,CAAMN,CAAA,GAAsB;MAC9D,IAAIF,CAAA,KAAcS,CAAA,CAAcC,EAAA,EAG9B,QADiBH,IAAA,CAAKI,IAAA,CAAKP,CAAA,GAAaF,CAAA,IACrB,KAAKA,CAAA,GAAsBH,CAAA;MAEhD,IAAIC,CAAA,KAAcS,CAAA,CAAcG,IAAA,EAE9B,OAAOb,CAAA;MAET,IAAIC,CAAA,KAAcS,CAAA,CAAcI,IAAA,EAAM;QAIpC,KAFA,IAAIP,CAAA,GAASJ,CAAA,GAAsB,GAC7BY,CAAA,GAAWP,IAAA,CAAKC,KAAA,EAAOJ,CAAA,GAAa,KAAK,IAC/BU,CAAA,GAATR,CAAA,GACLA,CAAA,IAAUJ,CAAA;QAEZ,OAAOI,CACR;MAAA;MACD,IAAIN,CAAA,KAAcS,CAAA,CAAcM,KAAA,EAAO;QAIrC,KAFA,IAAIC,CAAA,GAAS,GACPC,CAAA,GAAWV,IAAA,CAAKC,KAAA,EAAOJ,CAAA,GAAa,KAAK,IACTa,CAAA,GAA/BD,CAAA,GAASd,CAAA,GACdc,CAAA,IAAUd,CAAA;QAEZ,OAAOc,CACR;MAAA;IAAA,CAGc;EACjB,OAAOT,IAAA,CAAKW,GAAA,CAAI,GAAGX,IAAA,CAAKY,GAAA,CAAIb,CAAA,EAAUF,CAAA,GAAa,GACrD;AAAA;AAEA,SAASJ,EAAmCD,CAAA;EAY3C,IAXCC,CAAA,GAAWD,CAAA,CAAXqB,WAAA;IACAlB,CAAA,GAAUH,CAAA,CAAVM,UAAA;IACAD,CAAA,GAAmBL,CAAA,CAAnBI,mBAAA;IACSG,CAAA,GAAAP,CAAA,CACTsB,kBAAA;IAAAP,CAAA,QAAqB,MAAHR,CAAA,IAAQA,CAAA;IAQpBU,CAAA,GAAe,SAAAM,CAACb,CAAA;MAAa,OAAKF,IAAA,CAAKI,IAAA,EAAMF,CAAA,GAAQ,KAAKL,CAAA,CAAoB;IAAA;IAE9Ea,CAAA,GAAmB,SAAAM,CAACd,CAAA;MACxB,IAAIV,CAAA,GAAYC,CAAA,IAAeS,CAAA,GAAkB,KAAK;MAEtD,IAAgB,IAAZV,CAAA,IAAiBA,CAAA,IAAaG,CAAA,EAAY;QAC5C,KAAIY,CAAA,EAOF,OAAO;UAAEU,UAAA,GAAY;QAAA;QANL,IAAZzB,CAAA,GACFA,CAAA,GAAYG,CAAA,GAAa,IACHA,CAAA,GAAbH,CAAA,KACTA,CAAA,GAAY,EAKjB;MAAA;MAID,OAFoBiB,CAAA,CAAahB,CAAA,MACXgB,CAAA,CAAajB,CAAA,IAE1B;QAAEyB,UAAA,GAAY;MAAA,IAGhB;QAAEA,UAAA,GAAY;QAAOC,SAAA,EAAA1B;MAAA;IAAA;IAGxB2B,CAAA,GAAiB,SAAAC,CAAClB,CAAA;MACtB,IAAMV,CAAA,GAAYC,CAAA,GAAcI,CAAA,IAAuBK,CAAA,GAAkB,KAAK;MAC9E,OAAgB,IAAZV,CAAA,IAA+BA,CAAA,IAAdG,CAAA,GACZ;QAAEsB,UAAA,GAAY;MAAA,IAEhB;QAAEA,UAAA,GAAY;QAAOC,SAAA,EAAA1B;MAAA;IAAA;EAG9B,QA3CSA,CAAA,CAATE,SAAA;IA4CE,KAAKQ,CAAA,CAAcM,KAAA;MACjB,OAAOE,CAAA,EAAiB;IAC1B,KAAKR,CAAA,CAAcI,IAAA;MACjB,OAAOI,CAAA,EAAiB;IAC1B,KAAKR,CAAA,CAAcG,IAAA;MACjB,OAAOc,CAAA,EAAe;IACxB,KAAKjB,CAAA,CAAcC,EAAA;MACjB,OAAOgB,CAAA,EAAe;EAAA;AAE5B;AAAA,SAEgBxB,EAAmCO,CAAA;EAsBjD,KARD,IAZCV,CAAA,GAAUU,CAAA,CAAVJ,UAAA,EACAH,CAAA,GAAmBO,CAAA,CAAnBN,mBAAA,EACAC,CAAA,GAASK,CAAA,CAATR,SAAA,EAASK,CAAA,GAAAG,CAAA,CACTmB,eAAA,EAAAd,CAAA,QAAkB,MAAHR,CAAA,GAAG,KAAEA,CAAA,EAAAU,CAAA,GAAAP,CAAA,CACpBY,kBAAA,EAAAJ,CAAA,QAAqB,MAAHD,CAAA,IAAQA,CAAA,EAStBU,CAAA,GAAS1B,CAAA,CAAoC;MAC/CoB,WAAA,EAfSX,CAAA,CAAXW,WAAA;MAgBEf,UAAA,EAAAN,CAAA;MACAI,mBAAA,EAAAD,CAAA;MACAD,SAAA,EAAAG,CAAA;MACAiB,kBAAA,EAAAJ;IAAA,KAEMS,CAAA,CAAOF,UAAA,IAAcV,CAAA,CAAgBe,QAAA,CAASH,CAAA,CAAOD,SAAA,IAC3DC,CAAA,GAAS1B,CAAA,CAAoC;IAC3CoB,WAAA,EAAaM,CAAA,CAAOD,SAAA;IACpBpB,UAAA,EAAAN,CAAA;IACAI,mBAAA,EAAAD,CAAA;IACAD,SAAA,EAAAG,CAAA;IACAiB,kBAAA,EAAAJ;EAAA;EAIJ,OAAOS,CACT;AAAA;AAAA,SAAAxB,CAAA,IAAA4B,mCAAA,EAAA/B,CAAA,IAAAgC,mCAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}